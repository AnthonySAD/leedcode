# 题目

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

# 分析

看到时间复杂度为log(n)，就知道大概是用二分法直接查找中位数了。但是我很久没做数学题了，完全没头绪该如何查找，看了答案才明白过来，是直接用计算（公式）来定位并判定。

# 标答思路分析
> 以下为本人根据标答的分析，建议看过原文后再看下文。另外,我在代码中也配有注释。

- 在已排序好的数据中查找，二分法查找是非常合适的，时间复杂只有log（n）。
- 但是题目是要在2组数据中找到目标数据，所以没法使用。
- 因此有了一个想法，是否可以用二分法在2组数据中分别找到某个数据，然后再通过计算得到中位数。
- 然后就是开始找规律(推导公式)了，目标是：推导出需要找到什么样的数据，才能计算出中位数。
- 中位数有个特点就是<=中位数的数据数量等于>=中位数的。
- 所以从这方面入手，可以把数组a、b都分成2集合，使a+b的左集合<=中位数，a+b右集合>=中位数，并确保左右集合数量相等。则只要找到a、b的分隔点，就能直接计算出中位数，因为a、b本来就是有序排列的，分隔点就是左集合的最大值、右集合的最小值。
所以设a的分隔位置为aP，b的分割位置为bP，a的长度为aLen，b的长度为bLen。
- 则aP + bP = aLen - aP + bLen -bP(左集合数量等于右集合数量)
- aP + bP = (aLen + bLen)/2
- bP = (aLen + bLen)/2 - aP(如果总数为奇数,则bP = (aLen + bLen + 1)/2 - aP)
- 当aP为定值时，bP为唯一解，因此本题变为了使用二分法求出aP的位置。
- aP需要满足的条件为:(aP-1)的值 <= bP的值且(bP-1)的值 <= aP的值
- 当aLen + bLen为奇数时,则最终答案为max(aP-1, bP-1),当aLen + bLen为偶数时,则最终答案为(max(aP-1, bP-1) + min(aP, bP))/2

# 总结

由于我还不太会写java及二分法，所以就模范标答来写了。